## SSS-6412 契約終止及期滿統計表

### 1. 查詢日期 vs 終止日（為什麼會不一樣？）——無程式碼版說明

- **查詢日期**  
  - 由查詢畫面 `w_sss6412_query` 輸入的 `tx_date1`、`tx_date2` 組成。  
  - 報表抬頭的「查詢日期：起 ~~ 訖」純粹是把這兩個參數直接印出。  
- **終止日**  
  - 不是畫面輸入的日期，而是資料中每筆契約的「到期日／解約日」欄位 `purchase_maturity_date` 的實際值。  
  - 報表抬頭的「終止日：起 ~~ 訖」是用該次查詢抓回來所有資料的 `purchase_maturity_date` 去算 **最小值/最大值** 後印出。  
- **範圍差異的原因**  
  - 查詢條件會把母基金的到期日限制在「調整後的查詢區間」（考慮 MA/非 MA 的營業日位移），但實際每筆契約的到期日未必剛好落在畫面輸入的 `tx_date1`、`tx_date2` 邊界。  
  - 因此：  
    - 「查詢日期」顯示的是**使用者輸入的區間**。  
    - 「終止日」顯示的是**本次查出資料中，實際契約到期日的最早與最晚日期**。  
  - 兩者不同是正常的，用意是讓使用者知道：本次查詢結果中，實際終止日的分布範圍為何。

### 2. 查詢日期 vs 終止日——程式碼版說明

- **查詢條件來源**

```25:41:丟/SSS/SSS6412/w_sss6412_query.srw
ld_tx_date1      = dw_1.GetItemDate(dw_1.GetRow(),'tx_date1')
ld_tx_date2      = dw_1.GetItemDate(dw_1.GetRow(),'tx_date2')
...
// MA 類基金往前平移 4 個營業日
if ls_ma_type='1' then
    ld_tx_date3 = date(f_relative_date_tdcc(datetime(ld_tx_date1),-4))
else
    ld_tx_date3 = ld_tx_date1
end if
...
if ls_ma_type='1' then
    ld_tx_date4 = date(f_relative_date_tdcc(datetime(ld_tx_date2),-4))
else
    ld_tx_date4 = ld_tx_date2
end if
...
ls_sss6411.tx_date1 = ld_tx_date1
ls_sss6411.tx_date2 = ld_tx_date2
ls_sss6411.tx_date3 = ld_tx_date3
ls_sss6411.tx_date4 = ld_tx_date4
CloseWithReturn(Parent , ls_sss6411)
```

- **主視窗帶入查詢條件並呼叫 DataWindow**

```23:47:丟/SSS/SSS6412/w_sss6412.srw
open(w_sss6412_query)
ls_sss6411     = Message.PowerObjectParm
ld_tx_date1    = ls_sss6411.tx_date1
ld_tx_date2    = ls_sss6411.tx_date2
...
ld_tx_date3    = ls_sss6411.tx_date3
ld_tx_date4    = ls_sss6411.tx_date4
...
dw_1.Retrieve(ld_tx_date1 , ld_tx_date2 , ls_sales_no , ls_fund_no ,ls_cancel_reason, ld_tx_date3, ld_tx_date4)
```

- **報表抬頭顯示的日期**

```168:169:丟/SSS/d_sss6412.srd
compute(band=header expression="'終止日：' + string( min( purchase_maturity_date for all),'YYYY/MM/DD')
                               + '  ~~  ' + string( max( purchase_maturity_date for all),'YYYY/MM/DD')" )  // 終止日
compute(band=header expression="'查詢日期：' + string( ld_tx_date1 ,'YYYY/MM/DD')
                               + '  ~~  ' + string(ld_tx_date2,'YYYY/MM/DD')" )                           // 查詢日期
```

- **到期日篩選條件**

```100:109:丟/SSS/d_sss6412.srd
( select fund_no,
         decode(is_tdcc,'Y',:ld_tx_date4,:ld_tx_date2) date_to,
         decode(is_tdcc,'Y',:ld_tx_date1,:ld_tx_date3) date_from
  from fas.fund ) a
...
and fas.purchase.maturity_date between a.date_from and a.date_to
```

> 小結：畫面輸入的 `tx_date1/tx_date2` → header 的「查詢日期」。  
> 經 MA/非 MA 調整後的 `date_from/date_to` → 用來篩選 `maturity_date`。  
> 最後再用資料中的 `purchase_maturity_date` 算出「終止日」起迄。

### 3. 契約終止平均報酬率、平均契約報酬率 — 無程式碼版公式

- **名詞定義**
  - **原始母基金申購金額（amount）**：`L2` 母基金的申購金額，已依基金小數位數處理，為每張契約的成本基礎。
  - **目前市值（current_value）**：依最近 NAV（`fund.prev_date`）與尚未到期/未贖回的憑證數計算的市值。
  - **到期市值（maturity_value）**：依契約到期日 `purchase.maturity_date` 的 NAV 與到期時的持有憑證數計算的市值。
  - **在途現金（cash_in_transit）**：截至最近 NAV 日前，已送出贖回但尚未入帳的金額（R3/R4）。
  - **到期在途現金（cash_in_transit_maturity）**：截至契約到期日，相關贖回在途金額（R3/R4）。

- **(1) 契約終止平均報酬率**  
  - 以 **「契約到期」的終值** 來算報酬率：  
  \[
    \text{契約終止平均報酬率}
    = \frac{\sum(\text{到期市值}) + \sum(\text{到期在途現金})}{\text{原始母基金申購金額}} - 1
  \]
  - 分子：同一契約（group 3）下，所有基金憑證在 **到期日 NAV** 計價的市值 + 截至到期日的贖回在途金額。  
  - 分母：該契約的原始母基金申購金額（成本）。  

- **(2) 平均契約報酬率**  
  - 以 **「最近 NAV 日期」的市值** 來算目前報酬率：  
  \[
    \text{平均契約報酬率}
    = \frac{\sum(\text{目前市值}) + \sum(\text{在途現金})}{\text{原始母基金申購金額}} - 1
  \]
  - 分子：同一契約在最近 NAV 日的市值 + 截至該日的贖回在途金額。  
  - 分母：同樣是契約原始申購金額。  
  - 報表上備註：「平均契約報酬率為目前最近淨值顯示報酬率」，即說明是**以最新 NAV** 計算，而不是到期時。

### 4. 契約終止平均報酬率、平均契約報酬率 — 程式碼版公式

- **市值與金額計算欄位**

```177:183:丟/SSS/d_sss6412.srd
compute name=maturity_value  expression="maturity_nav * maturity_shares"
compute name=current_value   expression="current_nav * shares"
...
column  name=amount          // 母基金原始申購金額
column  name=cash_in_transit
column  name=cash_in_transit_maturity
```

- **(1) 契約終止平均報酬率（group 3 = 單一契約 master_no）**

```182:183:丟/SSS/d_sss6412.srd
compute name=compute_10  // 契約終止平均報酬率
 expression="(sum(maturity_value for group 3)
            + sum(cash_in_transit_maturity for group 3)) / amount - 1"
 format="###,##0.00%"
```

- **(2) 平均契約報酬率（以最近 NAV）**

```182:182:丟/SSS/d_sss6412.srd
compute name=compute_1   // 平均契約報酬率
 expression="(sum(current_value for group 3)
            + sum(cash_in_transit for group 3)) / amount - 1"
 format="###,##0.00%"
```

> 因為 DataWindow 的 group 3 以 `master_no` 群組 (`group(level=3 ... by=("master_no"))`)，上述兩個公式都是「**單一契約**」層級的報酬率。  
> 各分公司/業務員小計與總計區塊，只是再對這些契約層級的資料做筆數統計與金額合計，報酬率仍是依每一筆契約的計算邏輯。

---

## SSS-643 基金每日申購檔（台幣 / 外幣 EC 扣款檔）

### 1. 1.1／1.2 台幣、外幣產檔邏輯 — 無程式碼版說明

#### 1.1 台幣檔（`1_台幣yyyy-mm.xlsx`）

- **輸入條件**
  - 視窗 `w_sss643` 上的日期區間 `start_date`、`end_date`。  
  - 本功能主要使用 `end_date` 作為**截至日**；`start_date` 僅作為查詢 UI 範圍，對 1.1/1.2 的 SQL 並未實際使用。  

- **資料範圍（台幣 EC 扣款成功）**
  - 來源為 EC 自動扣款設定 `FAS.HOLDER_BANK_EC` 以及基金客戶/業務/團隊資料：  
    - 僅抓 **台幣相關帳戶**：`A.CURRENCY_NO = 'MMA' 或 'NTD'`。  
    - 僅抓 **保管機構 = '01'** 的帳戶。  
    - 只取 **帳戶已生效**：`A.VERIFIED <= end_date`。  
  - 判斷「台幣扣款成功」：  
    - 從 `ECS.PURCHASE` 中找出  
      - `TX_DATE <= end_date`  
      - `CURRENCY_NO = 'NTD'`  
      - `RESULT_CODE = '00'`（扣款成功）  
    - 依 `ID` + 銀行與帳號 (`BANK_NO`、`AC_CODE`) 與 EC 設定比對；若有任一筆成功紀錄即視為該戶「台幣扣款成功 = Y」，否則為 N。  
  - 結果資料欄位：  
    - 組別（分公司/團隊）、業務代碼、業務姓名、EC 開戶戶號、台幣扣款成功(Y/N)。  
  - 最終輸出：把查詢結果寫出到 Excel 檔 `1_台幣yyyy-mm.xlsx`，檔名中的 `yyyy-mm` 取自輸入的 `end_date`。

#### 1.2 外幣檔（`2_外幣yyyy-mm.xlsx`）

- **輸入條件**
  - 同樣使用 `start_date`、`end_date`，實際 SQL 只用到 `end_date` 作為**截至日**，`start_date` 在 1.2 邏輯中未參與條件。  

- **資料範圍（外幣 EC 扣款成功）**
  - 來源仍為 `FAS.HOLDER_BANK_EC` + 客戶/業務/團隊 + `ECS.PURCHASE`。  
  - EC 帳戶條件：  
    - `A.CURRENCY_NO = 'FCY'` 或「**非 NTD 也非 MMA**」的幣別（其他外幣）。  
    - `A.VERIFIED <= end_date`。  
    - `A.DEPOSITORY_NO = '01'`。  
  - 判斷「外幣扣款成功」：  
    - 從 `ECS.PURCHASE` 中找出  
      - `TX_DATE <= end_date`  
      - `CURRENCY_NO <> 'NTD'`（外幣）  
      - `RESULT_CODE = '00'`  
    - 同樣依 `ID` + `BANK_NO` + `AC_CODE` 去比對 EC 設定，有成功紀錄則「外幣扣款成功 = Y」，否則 N。  
  - 結果欄位與台幣檔相同，只是成功欄位為「外幣扣款成功」。  
  - 最終輸出：Excel 檔 `2_外幣yyyy-mm.xlsx`，年月同樣取自 `end_date`。

### 2. 1.1／1.2 台幣、外幣產檔邏輯 — 程式碼版說明

#### 2.1 主流程（視窗 `w_sss643`）

- **讀取查詢條件與基本檢核**

```191:210:丟/SSS/SSS6412/w_sss643.srw
dw_1.AcceptText()
ld_start_date = dw_1.GetItemDate(dw_1.GetRow(),'start_date')
ld_end_date   = dw_1.GetItemDate(dw_1.GetRow(),'end_date')
if isnull(ld_start_date) or string(ld_start_date,'YYYY/MM/DD') = '1900/01/01' or &
   isnull(ld_end_date)   or string(ld_end_date  ,'YYYY/MM/DD') = '1900/01/01' then
    f_error('請輸入交易日期')
    return
end if
```

- **1.1 台幣：設定 DataWindow 並輸出**

```218:231:丟/SSS/SSS6412/w_sss643.srw
if cbx_1.checked = true then
    ls_xls_filename1 = '1_台幣' + string(ld_end_date,'YYYY-MM') + '.xlsx'
    wf_progress(" 轉出EXCEL，檔名：" + sle_file.text + ls_xls_filename1)

    lds_1.DataObject = 'd_sss643_1'
    lds_1.SetTransObject(sqlca)
    lds_1.Retrieve(ld_start_date, ld_end_date)   // 參數帶入，但 SQL 僅使用 end_date

    ll_error = lds_1.SaveAs (sle_file.text + ls_xls_filename1, xlsx!, true )
    ...
end if
```

- **1.2 外幣：設定 DataWindow 並輸出**

```241:252:丟/SSS/SSS6412/w_sss643.srw
if cbx_2.checked = true then
    ls_xls_filename1 = '2_外幣' + string(ld_end_date,'YYYY-MM') + '.xlsx'
    wf_progress(" 轉出EXCEL，檔名：" + sle_file.text + ls_xls_filename1)

    lds_1.DataObject = 'd_sss643_2'
    lds_1.SetTransObject(sqlca)
    lds_1.Retrieve(ld_start_date, ld_end_date)   // 同樣只在 SQL 中用到 end_date

    ll_error = lds_1.SaveAs (sle_file.text + ls_xls_filename1, xlsx!, true )
    ...
end if
```

#### 2.2 台幣 DataWindow `d_sss643_1`

- **SQL 節錄**

```14:31:丟/SSS/SSS6412/d_sss643_1.srd
SELECT D.NAME AS 組別,
       B.SALES_NO AS 業務代碼,
       E.NAME AS 業務姓名,
       B.ACCOUNT_NO AS EC開戶戶號,
       CASE WHEN F.ID IS NOT NULL THEN 'Y' ELSE 'N' END AS 台幣扣款成功
  FROM FAS.HOLDER_BANK_EC A
  JOIN FAS.HOLDER B        ON A.ID = B.ID
  JOIN SSS.TEAM_MEMBER C   ON B.SALES_NO = C.SALES_NO
  JOIN SSS.TEAM D          ON C.TEAM_NO = D.TEAM_NO
                          AND D.PROFIT_CENTER = 'DS'
                          AND D.NAME IN ('台北一組','台北二組','台中分公司','高雄分公司')
  JOIN FAS.SALES E         ON B.SALES_NO = E.SALES_NO
  LEFT JOIN (
       SELECT DISTINCT ID ,BANK_NO , AC_CODE
         FROM ECS.PURCHASE
        WHERE TX_DATE    <= :ld_end_date      -- 僅使用 end_date
          AND CURRENCY_NO = 'NTD'
          AND RESULT_CODE = '00'
       ) F
    ON F.ID      = B.ID
   AND F.BANK_NO = A.AC_BANK
   AND F.AC_CODE = A.AC_CODE
 WHERE (A.CURRENCY_NO = 'MMA' OR A.CURRENCY_NO = 'NTD')
   AND A.VERIFIED     <= :ld_end_date
   AND A.DEPOSITORY_NO = '01'
GROUP BY D.NAME, B.SALES_NO, E.NAME, B.ACCOUNT_NO, F.ID
```

> `ld_start_date` 雖然有被 `Retrieve(ld_start_date, ld_end_date)` 帶入，但此 SQL 僅宣告 `("ld_start_date", date),("ld_end_date", date)`，實際條件只用到 `:ld_end_date`，代表這個檔案邏輯是「**截至某日的狀態**」，不是區間內變化。

#### 2.3 外幣 DataWindow `d_sss643_2`

- **SQL 節錄**

```14:31:丟/SSS/SSS6412/d_sss643_2.srd
SELECT D.NAME AS 組別,
       B.SALES_NO AS 業務代碼,
       E.NAME AS 業務姓名,
       B.ACCOUNT_NO AS EC開戶戶號,
       CASE WHEN F.ID IS NOT NULL THEN 'Y' ELSE 'N' END AS 外幣扣款成功
  FROM FAS.HOLDER_BANK_EC A
  JOIN FAS.HOLDER B        ON A.ID = B.ID
  JOIN SSS.TEAM_MEMBER C   ON B.SALES_NO = C.SALES_NO
  JOIN SSS.TEAM D          ON C.TEAM_NO = D.TEAM_NO
                          AND D.PROFIT_CENTER = 'DS'
                          AND D.NAME IN ('台北一組','台北二組','台中分公司','高雄分公司')
  JOIN FAS.SALES E         ON B.SALES_NO = E.SALES_NO
  LEFT JOIN (
       SELECT DISTINCT ID ,BANK_NO , AC_CODE
         FROM ECS.PURCHASE
        WHERE TX_DATE    <= :ld_end_date      -- 同樣只使用 end_date
          AND CURRENCY_NO <> 'NTD'
          AND RESULT_CODE = '00'
       ) F
    ON F.ID      = B.ID
   AND F.BANK_NO = A.AC_BANK
   AND F.AC_CODE = A.AC_CODE
 WHERE (A.CURRENCY_NO = 'FCY'
     OR (A.CURRENCY_NO <> 'NTD' AND A.CURRENCY_NO <> 'MMA'))
   AND A.VERIFIED     <= :ld_end_date
   AND A.DEPOSITORY_NO = '01'
GROUP BY D.NAME, B.SALES_NO, E.NAME, B.ACCOUNT_NO, F.ID
```

> 外幣檔的結構與台幣幾乎完全相同，只是判斷幣別條件改成「非 NTD」、且 EC 設定幣別範圍改成外幣。  
> 這兩個檔案的核心邏輯都是：**截至某一日 (end_date)，哪些 EC 帳戶曾經成功扣款。**

